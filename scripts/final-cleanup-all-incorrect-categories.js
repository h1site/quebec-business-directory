/**
 * NETTOYAGE FINAL ET COMPLET
 *
 * R√©initialise main_category_id √† NULL pour TOUTES les entreprises qui ont:
 * - main_category_id assign√© (non NULL)
 * - MAIS categories = [] (vide)
 *
 * R√®gle: Si une entreprise n'a PAS de vraie cat√©gorisation (categories=[]),
 * elle ne devrait PAS avoir de main_category_id assign√©.
 *
 * Cela emp√™che les entreprises non pertinentes d'appara√Ætre dans les recherches par cat√©gorie.
 */

import { createClient } from '@supabase/supabase-js';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({ path: path.join(__dirname, '..', '.env') });

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('‚ùå Variables Supabase manquantes!');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

const BATCH_SIZE = 50; // Petit batch pour √©viter les timeouts

console.log('üßπ NETTOYAGE FINAL - TOUTES CAT√âGORISATIONS INCORRECTES\n');
console.log('‚ïê'.repeat(80));
console.log('\n‚ö†Ô∏è  CE SCRIPT VA:');
console.log('   1. Trouver TOUTES les entreprises avec main_category_id assign√©');
console.log('   2. R√©initialiser √† NULL si categories=[]');
console.log('   3. Tourner jusqu\'√† ce qu\'il n\'y ait plus rien √† nettoyer\n');
console.log('‚ïê'.repeat(80));

let totalCleaned = 0;
let passNumber = 1;
let foundProblems = true;

while (foundProblems) {
  console.log(`\nüîÑ PASSE #${passNumber}\n`);

  // R√©cup√©rer un batch d'entreprises avec main_category_id
  const { data: batch, error } = await supabase
    .from('businesses')
    .select('id, neq, name, main_category_id, categories, act_econ_code')
    .not('main_category_id', 'is', null)
    .limit(1000);

  if (error) {
    console.error('‚ùå Erreur r√©cup√©ration:', error);
    break;
  }

  if (!batch || batch.length === 0) {
    console.log('‚úÖ Aucune entreprise avec main_category_id trouv√©e');
    foundProblems = false;
    break;
  }

  // Filtrer celles avec categories vide
  const toClean = batch.filter(b => !b.categories || b.categories.length === 0);

  if (toClean.length === 0) {
    console.log('‚úÖ Aucune entreprise mal cat√©goris√©e dans ce batch');
    foundProblems = false;
    break;
  }

  console.log(`   Trouv√©: ${toClean.length} entreprises √† nettoyer (sur ${batch.length})`);

  // Afficher √©chantillon
  if (passNumber === 1) {
    console.log('\n   üìã √âchantillon (5 premiers):');
    toClean.slice(0, 5).forEach((biz, i) => {
      console.log(`   ${i + 1}. NEQ ${biz.neq}: ${biz.name?.substring(0, 50)}`);
      console.log(`      act_econ_code: ${biz.act_econ_code || 'NULL'}`);
    });
    console.log('');
  }

  // Nettoyer par petits batches
  let cleaned = 0;
  for (let i = 0; i < toClean.length; i += BATCH_SIZE) {
    const smallBatch = toClean.slice(i, i + BATCH_SIZE);
    const ids = smallBatch.map(b => b.id);

    const { error: updateError } = await supabase
      .from('businesses')
      .update({ main_category_id: null })
      .in('id', ids);

    if (updateError) {
      console.error(`   ‚ùå Erreur update batch ${Math.floor(i / BATCH_SIZE) + 1}:`, updateError);
    } else {
      cleaned += smallBatch.length;
      const progress = Math.round((cleaned / toClean.length) * 100);
      process.stdout.write(`\r   Nettoyage: ${cleaned}/${toClean.length} (${progress}%)`);
    }
  }

  console.log(`\n   ‚úÖ Passe #${passNumber}: ${cleaned} entreprises nettoy√©es\n`);
  totalCleaned += cleaned;
  passNumber++;

  // Limite de s√©curit√©
  if (passNumber > 200) {
    console.log('‚ö†Ô∏è  Limite de 200 passes atteinte');
    break;
  }
}

console.log('\n' + '‚ïê'.repeat(80));
console.log('\nüéâ NETTOYAGE FINAL TERMIN√â\n');
console.log(`   Total entreprises nettoy√©es: ${totalCleaned.toLocaleString()}`);
console.log(`   Nombre de passes: ${passNumber - 1}`);

// V√©rification finale
console.log('\nüìä V√âRIFICATION FINALE...\n');

const { data: remaining } = await supabase
  .from('businesses')
  .select('id, categories, main_category_id')
  .not('main_category_id', 'is', null)
  .limit(10000);

const stillBad = remaining?.filter(b => !b.categories || b.categories.length === 0).length || 0;

if (stillBad === 0) {
  console.log('‚úÖ PARFAIT! Aucune entreprise mal cat√©goris√©e restante!');
} else {
  console.log(`‚ö†Ô∏è  Il reste encore ${stillBad.toLocaleString()} entreprises mal cat√©goris√©es`);
  console.log('   (probablement dans un batch suivant, relancer le script)');
}

console.log('\nüí° Les entreprises avec categories=[] n\'appara√Ætront plus dans les recherches par cat√©gorie');
