import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(
  process.env.VITE_SUPABASE_URL,
  process.env.VITE_SUPABASE_ANON_KEY
);

console.log('üè∑Ô∏è  ASSIGNMENT DES CAT√âGORIES EN MASSE (SQL Direct)\n');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

console.log('üöÄ Mise √† jour des cat√©gories pour toutes les entreprises avec ACT_ECON...\n');

// Utiliser une requ√™te UPDATE avec JOIN
const updateQuery = `
  UPDATE businesses b
  SET
    category = c.slug,
    sub_category = m.sub_category_id
  FROM act_econ_category_mappings m
  JOIN categories c ON c.id = m.main_category_id
  WHERE
    b.act_econ_code = m.act_econ_code
    AND b.category IS NULL
    AND m.confidence_score >= 0.5
  RETURNING b.id;
`;

console.log('Ex√©cution de la requ√™te UPDATE...\n');
console.log('‚è≥ Cela peut prendre quelques secondes...\n');

try {
  // Utiliser le client SQL directement via rpc
  const { data, error } = await supabase.rpc('exec_sql', { query: updateQuery });

  if (error) {
    // Si la fonction n'existe pas, faire une approche alternative
    console.log('üí° Approche alternative: mise √† jour par batches...\n');

    // R√©cup√©rer tous les mappings
    const { data: mappings } = await supabase
      .from('act_econ_category_mappings')
      .select(`
        act_econ_code,
        main_category_id,
        sub_category_id,
        categories:main_category_id (slug)
      `)
      .gte('confidence_score', 0.5);

    if (!mappings) {
      console.error('‚ùå Impossible de charger les mappings');
      process.exit(1);
    }

    console.log(`üìä ${mappings.length} mappings charg√©s\n`);

    let updated = 0;
    const BATCH_SIZE = 50;

    // Traiter par batch
    for (let i = 0; i < mappings.length; i += BATCH_SIZE) {
      const batch = mappings.slice(i, i + BATCH_SIZE);

      // Pour chaque mapping dans le batch
      for (const mapping of batch) {
        if (mapping.categories) {
          const { error: updateError } = await supabase
            .from('businesses')
            .update({
              category: mapping.categories.slug,
              sub_category: mapping.sub_category_id
            })
            .eq('act_econ_code', mapping.act_econ_code)
            .is('category', null);

          if (!updateError) {
            updated++;
            if (updated % 100 === 0) {
              console.log(`   ‚úÖ ${updated} codes ACT_ECON trait√©s...`);
            }
          }
        }
      }
    }

    console.log(`\n‚úÖ Traitement termin√©! ${updated} codes ACT_ECON trait√©s\n`);
  } else {
    console.log('‚úÖ Mise √† jour termin√©e via SQL direct!\n');
  }
} catch (err) {
  console.error('‚ùå Erreur:', err.message);
}

// V√©rifier les r√©sultats
console.log('üîç V√©rification des statistiques...\n');

const { count: withCategory } = await supabase
  .from('businesses')
  .select('*', { count: 'exact', head: true })
  .not('category', 'is', null);

const { count: withActEcon } = await supabase
  .from('businesses')
  .select('*', { count: 'exact', head: true })
  .not('act_econ_code', 'is', null);

console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log(`Entreprises avec ACT_ECON: ${withActEcon?.toLocaleString() || 0}`);
console.log(`Entreprises avec cat√©gorie: ${withCategory?.toLocaleString() || 0}`);
console.log(`Taux d'assignment: ${((withCategory / withActEcon) * 100).toFixed(1)}%`);
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

console.log('‚úÖ Termin√©!\n');
