import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(
  process.env.VITE_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY
);

async function verifyActEconCoverage() {
  console.log('üîç V√©rification de la couverture act_econ_code dans businesses...\n');
  console.log('='.repeat(80));

  // 1. Total des entreprises
  const { count: total, error: totalError } = await supabase
    .from('businesses')
    .select('*', { count: 'exact', head: true });

  if (totalError) {
    console.error('‚ùå Erreur:', totalError);
    return;
  }

  console.log(`\nüìä TOTAL ENTREPRISES: ${total?.toLocaleString()}`);

  // 2. Avec act_econ_code (NOT NULL)
  const { count: withActEcon, error: withError } = await supabase
    .from('businesses')
    .select('*', { count: 'exact', head: true })
    .not('act_econ_code', 'is', null);

  console.log(`\n‚úÖ AVEC act_econ_code: ${withActEcon?.toLocaleString()} (${((withActEcon/total)*100).toFixed(2)}%)`);

  // 3. Sans act_econ_code (NULL)
  const { count: withoutActEcon, error: withoutError } = await supabase
    .from('businesses')
    .select('*', { count: 'exact', head: true })
    .is('act_econ_code', null);

  console.log(`‚ùå SANS act_econ_code (NULL): ${withoutActEcon?.toLocaleString()} (${((withoutActEcon/total)*100).toFixed(2)}%)`);

  // 4. √âchantillon avec act_econ_code
  console.log('\n' + '='.repeat(80));
  console.log('üìã √âCHANTILLON: Entreprises AVEC act_econ_code');
  console.log('='.repeat(80));

  const { data: withSample } = await supabase
    .from('businesses')
    .select('name, act_econ_code, city')
    .not('act_econ_code', 'is', null)
    .limit(10);

  if (withSample && withSample.length > 0) {
    console.log('');
    for (const biz of withSample) {
      // Lookup label from act_econ_codes or act_econ_main
      const { data: codeLabel } = await supabase
        .from('act_econ_codes')
        .select('label_fr')
        .eq('code', biz.act_econ_code)
        .single();

      const { data: mainLabel } = await supabase
        .from('act_econ_main')
        .select('label_fr')
        .eq('code', biz.act_econ_code)
        .single();

      const label = codeLabel?.label_fr || mainLabel?.label_fr || 'Code non trouv√©';

      console.log(`‚úì ${biz.name} (${biz.city || 'N/A'})`);
      console.log(`  ‚Üí ${biz.act_econ_code}: ${label}`);
    }
  }

  // 5. √âchantillon SANS act_econ_code
  console.log('\n' + '='.repeat(80));
  console.log('üìã √âCHANTILLON: Entreprises SANS act_econ_code (NULL)');
  console.log('='.repeat(80));

  const { data: withoutSample } = await supabase
    .from('businesses')
    .select('name, act_econ_code, city, main_category_id')
    .is('act_econ_code', null)
    .limit(10);

  if (withoutSample && withoutSample.length > 0) {
    console.log('');
    for (const biz of withoutSample) {
      console.log(`‚úó ${biz.name} (${biz.city || 'N/A'})`);
      console.log(`  ‚Üí act_econ_code: NULL`);
      console.log(`  ‚Üí main_category_id: ${biz.main_category_id || 'NULL'}`);
    }
  } else {
    console.log('\nüéâ AUCUNE ENTREPRISE SANS act_econ_code!');
    console.log('   Couverture √† 100% confirm√©e! ‚úÖ');
  }

  // 6. Distribution des codes ACT_ECON
  console.log('\n' + '='.repeat(80));
  console.log('üìä DISTRIBUTION DES CODES ACT_ECON (TOP 20)');
  console.log('='.repeat(80));

  const { data: distribution } = await supabase
    .from('businesses')
    .select('act_econ_code')
    .not('act_econ_code', 'is', null);

  if (distribution) {
    // Count occurrences
    const counts = {};
    distribution.forEach(row => {
      counts[row.act_econ_code] = (counts[row.act_econ_code] || 0) + 1;
    });

    // Sort by count
    const sorted = Object.entries(counts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 20);

    console.log('');
    for (const [code, count] of sorted) {
      // Get label
      const { data: codeLabel } = await supabase
        .from('act_econ_codes')
        .select('label_fr')
        .eq('code', code)
        .single();

      const { data: mainLabel } = await supabase
        .from('act_econ_main')
        .select('label_fr')
        .eq('code', code)
        .single();

      const label = codeLabel?.label_fr || mainLabel?.label_fr || 'N/A';
      const percentage = ((count / total) * 100).toFixed(2);

      console.log(`${code}: ${count.toLocaleString()} entreprises (${percentage}%)`);
      console.log(`   ‚Üí ${label}`);
    }
  }

  // 7. Codes invalides (qui n'existent pas dans act_econ_main ou act_econ_codes)
  console.log('\n' + '='.repeat(80));
  console.log('‚ö†Ô∏è  CODES INVALIDES (n\'existent pas dans act_econ_main/codes)');
  console.log('='.repeat(80));

  const { data: allCodes } = await supabase
    .from('businesses')
    .select('act_econ_code')
    .not('act_econ_code', 'is', null);

  if (allCodes) {
    const uniqueCodes = [...new Set(allCodes.map(row => row.act_econ_code))];
    console.log(`\nüìù ${uniqueCodes.length} codes uniques trouv√©s dans businesses`);

    let invalidCount = 0;
    const invalidCodes = [];

    for (const code of uniqueCodes.slice(0, 100)) { // Check first 100
      const { data: inCodes } = await supabase
        .from('act_econ_codes')
        .select('code')
        .eq('code', code)
        .single();

      const { data: inMain } = await supabase
        .from('act_econ_main')
        .select('code')
        .eq('code', code)
        .single();

      if (!inCodes && !inMain) {
        invalidCount++;
        invalidCodes.push(code);
      }
    }

    if (invalidCount > 0) {
      console.log(`\n‚ö†Ô∏è  ${invalidCount} codes invalides d√©tect√©s (√©chantillon 100):`);
      invalidCodes.slice(0, 10).forEach(code => {
        console.log(`   - ${code}`);
      });
    } else {
      console.log('\n‚úÖ Tous les codes sont valides! (√©chantillon de 100 v√©rifi√©s)');
    }
  }

  // 8. R√©sum√© final
  console.log('\n' + '='.repeat(80));
  console.log('üìù R√âSUM√â FINAL');
  console.log('='.repeat(80));
  console.log(`
Total entreprises:        ${total?.toLocaleString()}
Avec act_econ_code:       ${withActEcon?.toLocaleString()} (${((withActEcon/total)*100).toFixed(2)}%)
Sans act_econ_code:       ${withoutActEcon?.toLocaleString()} (${((withoutActEcon/total)*100).toFixed(2)}%)
  `);

  if (withActEcon === total) {
    console.log('üéâ COUVERTURE √Ä 100% CONFIRM√âE! ‚úÖ');
    console.log('   Toutes les entreprises ont un act_econ_code!');
    console.log('\nüí° PROCHAINE √âTAPE:');
    console.log('   ‚Üí Cr√©er le mapping act_econ_code ‚Üí main_category_id');
    console.log('   ‚Üí Assigner automatiquement les main_category_id');
    console.log('   ‚Üí Les filtres front-end fonctionneront!');
  } else {
    console.log(`‚ö†Ô∏è  ${withoutActEcon?.toLocaleString()} entreprises n'ont pas de act_econ_code`);
    console.log('   Ces entreprises ne pourront pas √™tre auto-cat√©goris√©es');
  }

  console.log('='.repeat(80));
}

verifyActEconCoverage();
