import { createClient } from '@supabase/supabase-js';
import fs from 'fs';
import readline from 'readline';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(
  process.env.VITE_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY
);

const CSV_PATH = 'data/entreprise.csv';
const BATCH_SIZE = 500; // Plus gros batch pour moins de requ√™tes

function cleanActEconCode(codeStr) {
  if (!codeStr || codeStr === 'NON D√âCLAR√â' || codeStr === '') {
    return null;
  }

  const num = parseInt(codeStr, 10);

  if (isNaN(num) || num < 100) {
    return null;
  }

  return num.toString().padStart(4, '0');
}

async function syncActEconOptimized() {
  console.log('üöÄ Synchronisation ACT_ECON OPTIMIS√âE\n');
  console.log('='.repeat(80));

  console.log('\n1Ô∏è‚É£ Lecture du CSV et cr√©ation du mapping...\n');

  const fileStream = fs.createReadStream(CSV_PATH);
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity
  });

  const neqToActEcon = new Map();
  let csvLines = 0;
  let validCodes = 0;
  let invalidCodes = 0;
  let isFirstLine = true;

  for await (const line of rl) {
    if (isFirstLine) {
      isFirstLine = false;
      continue;
    }

    csvLines++;

    if (csvLines % 100000 === 0) {
      console.log(`   Trait√©: ${csvLines.toLocaleString()} lignes...`);
    }

    const columns = line.split(',');

    if (columns.length < 19) {
      continue;
    }

    const neq = columns[0];
    const codActEconCae = columns[17];
    const noActEconAssuj = columns[18];

    let actEcon = cleanActEconCode(noActEconAssuj);
    if (!actEcon && codActEconCae) {
      actEcon = cleanActEconCode(codActEconCae);
    }

    if (actEcon && neq) {
      neqToActEcon.set(neq, actEcon);
      validCodes++;
    } else {
      invalidCodes++;
    }
  }

  console.log(`\n‚úÖ CSV trait√©:`);
  console.log(`   Total lignes: ${csvLines.toLocaleString()}`);
  console.log(`   Codes valides: ${validCodes.toLocaleString()}`);
  console.log(`   Codes invalides/manquants: ${invalidCodes.toLocaleString()}`);
  console.log(`   Mapping cr√©√©: ${neqToActEcon.size.toLocaleString()} NEQ ‚Üí ACT_ECON`);

  // R√©cup√©rer tous les NEQ de la base de donn√©es par batches
  console.log('\n2Ô∏è‚É£ R√©cup√©ration des entreprises depuis Supabase...\n');

  let allBusinesses = [];
  let offset = 0;
  const FETCH_BATCH = 10000;

  while (true) {
    const { data, error } = await supabase
      .from('businesses')
      .select('id, neq')
      .not('neq', 'is', null)
      .range(offset, offset + FETCH_BATCH - 1);

    if (error) {
      console.error('‚ùå Erreur:', error);
      break;
    }

    if (!data || data.length === 0) {
      break;
    }

    allBusinesses.push(...data);
    offset += FETCH_BATCH;

    console.log(`   R√©cup√©r√©: ${allBusinesses.length.toLocaleString()} entreprises...`);

    if (data.length < FETCH_BATCH) {
      break;
    }
  }

  console.log(`\n‚úÖ ${allBusinesses.length.toLocaleString()} entreprises r√©cup√©r√©es au total`);

  // Mise √† jour par batches
  console.log('\n3Ô∏è‚É£ Mise √† jour des codes ACT_ECON par batch...\n');

  let updated = 0;
  let notFound = 0;
  const totalBatches = Math.ceil(allBusinesses.length / BATCH_SIZE);

  console.log(`   ${totalBatches} batches √† traiter\n`);

  for (let i = 0; i < allBusinesses.length; i += BATCH_SIZE) {
    const batch = allBusinesses.slice(i, i + BATCH_SIZE);
    const batchNum = Math.floor(i / BATCH_SIZE) + 1;

    // Construire les updates pour ce batch
    const updates = [];
    for (const business of batch) {
      const actEconCode = neqToActEcon.get(business.neq);
      if (actEconCode) {
        updates.push({
          id: business.id,
          act_econ_code: actEconCode
        });
      } else {
        notFound++;
      }
    }

    // Faire les updates en parall√®le avec Promise.all pour plus de vitesse
    if (updates.length > 0) {
      const updatePromises = updates.map(update =>
        supabase
          .from('businesses')
          .update({ act_econ_code: update.act_econ_code })
          .eq('id', update.id)
      );

      const results = await Promise.all(updatePromises);

      const successCount = results.filter(r => !r.error).length;
      updated += successCount;
    }

    if (batchNum % 10 === 0 || batchNum === totalBatches) {
      const progress = ((i + batch.length) / allBusinesses.length * 100).toFixed(1);
      console.log(`üì¶ Batch ${batchNum}/${totalBatches} (${progress}%)`);
      console.log(`   ‚úÖ Total mis √† jour: ${updated.toLocaleString()}`);
      console.log(`   ‚è≠Ô∏è  Total non trouv√©s: ${notFound.toLocaleString()}\n`);
    }
  }

  console.log('='.repeat(80));
  console.log('‚úÖ SYNCHRONISATION TERMIN√âE!\n');
  console.log('üìä R√©sultat final:');
  console.log(`   ‚úÖ Mis √† jour: ${updated.toLocaleString()} entreprises`);
  console.log(`   ‚è≠Ô∏è  Non trouv√©s dans CSV: ${notFound.toLocaleString()}`);
  console.log(`   üìà Taux de mise √† jour: ${(updated / allBusinesses.length * 100).toFixed(2)}%`);
}

syncActEconOptimized().catch(console.error);
