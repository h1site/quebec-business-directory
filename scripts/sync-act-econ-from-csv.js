import { createClient } from '@supabase/supabase-js';
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(
  process.env.VITE_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY
);

const BATCH_SIZE = 500; // Process 500 businesses per batch
const CSV_PATH = path.join(process.cwd(), 'data', 'Entreprise.csv');

async function syncActEconFromCSV() {
  console.log('üîÑ Synchronisation des codes ACT_ECON depuis Entreprise.csv...\n');
  console.log('='.repeat(80));

  // 1. Lire le CSV (parsing manuel simple)
  console.log('\n1Ô∏è‚É£ Lecture du fichier CSV...');
  const csvContent = fs.readFileSync(CSV_PATH, 'utf-8');

  // Parse CSV manually (simple split)
  const lines = csvContent.split('\n');
  const headers = lines[0].replace(/^\uFEFF/, '').split(','); // Remove BOM

  const neqIndex = headers.indexOf('NEQ');
  const actEconIndex = headers.indexOf('NO_ACT_ECON_ASSUJ');

  console.log(`   Colonnes trouv√©es: NEQ (index ${neqIndex}), NO_ACT_ECON_ASSUJ (index ${actEconIndex})`);

  const records = [];
  for (let i = 1; i < lines.length; i++) {
    if (!lines[i].trim()) continue;

    const values = lines[i].split(',');
    if (values.length > Math.max(neqIndex, actEconIndex)) {
      records.push({
        NEQ: values[neqIndex]?.trim() || '',
        NO_ACT_ECON_ASSUJ: values[actEconIndex]?.trim() || ''
      });
    }
  }

  console.log(`‚úÖ ${records.length.toLocaleString()} lignes lues du CSV`);

  // 2. Filtrer les lignes avec NEQ et NO_ACT_ECON_ASSUJ
  console.log('\n2Ô∏è‚É£ Filtrage des donn√©es...');
  const validRecords = records.filter(row => {
    return row.NEQ &&
           row.NEQ.trim() !== '' &&
           row.NO_ACT_ECON_ASSUJ &&
           row.NO_ACT_ECON_ASSUJ.trim() !== '';
  });

  console.log(`‚úÖ ${validRecords.length.toLocaleString()} lignes valides (NEQ + ACT_ECON)`);
  console.log(`‚ùå ${(records.length - validRecords.length).toLocaleString()} lignes ignor√©es (manque NEQ ou ACT_ECON)`);

  // 3. Cr√©er un mapping NEQ ‚Üí ACT_ECON code format√©
  console.log('\n3Ô∏è‚É£ Cr√©ation du mapping NEQ ‚Üí ACT_ECON...');
  const neqToActEcon = new Map();

  validRecords.forEach(row => {
    const neq = row.NEQ.trim();
    const actEconCode = row.NO_ACT_ECON_ASSUJ.trim();

    // Format: Pad with 0 to get 4 digits (ex: 111 ‚Üí 0111)
    const formattedCode = actEconCode.padStart(4, '0');

    neqToActEcon.set(neq, formattedCode);
  });

  console.log(`‚úÖ ${neqToActEcon.size.toLocaleString()} mappings NEQ ‚Üí ACT_ECON cr√©√©s`);

  // 4. √âchantillon du mapping
  console.log('\nüìã √âchantillon du mapping:');
  const sampleEntries = Array.from(neqToActEcon.entries()).slice(0, 5);
  sampleEntries.forEach(([neq, code]) => {
    console.log(`   ${neq} ‚Üí ${code}`);
  });

  // 5. R√©cup√©rer les entreprises de Supabase avec NEQ mais sans act_econ_code
  console.log('\n4Ô∏è‚É£ R√©cup√©ration des entreprises Supabase sans act_econ_code...');

  const { count: totalWithoutCode } = await supabase
    .from('businesses')
    .select('*', { count: 'exact', head: true })
    .is('act_econ_code', null)
    .not('neq', 'is', null);

  console.log(`üìä ${totalWithoutCode?.toLocaleString()} entreprises avec NEQ mais sans act_econ_code`);

  // 6. Traiter par batch
  console.log('\n5Ô∏è‚É£ Traitement par batch...');
  console.log(`   Taille du batch: ${BATCH_SIZE}`);
  console.log(`   Batches estim√©s: ${Math.ceil(totalWithoutCode / BATCH_SIZE)}\n`);

  let processedCount = 0;
  let updatedCount = 0;
  let notFoundCount = 0;
  let batchNumber = 0;

  while (processedCount < totalWithoutCode) {
    batchNumber++;

    // Fetch batch
    const { data: businesses, error: fetchError } = await supabase
      .from('businesses')
      .select('id, neq, name')
      .is('act_econ_code', null)
      .not('neq', 'is', null)
      .range(0, BATCH_SIZE - 1); // Always get first BATCH_SIZE that match

    if (fetchError) {
      console.error(`‚ùå Erreur batch ${batchNumber}:`, fetchError);
      break;
    }

    if (!businesses || businesses.length === 0) {
      console.log('‚úÖ Aucune entreprise restante √† traiter');
      break;
    }

    console.log(`\nüì¶ Batch ${batchNumber} (${businesses.length} entreprises)`);

    // Update each business in batch
    const updates = [];

    for (const business of businesses) {
      const actEconCode = neqToActEcon.get(business.neq);

      if (actEconCode) {
        updates.push({
          id: business.id,
          neq: business.neq,
          act_econ_code: actEconCode
        });
      } else {
        notFoundCount++;
      }
    }

    // Execute batch update
    if (updates.length > 0) {
      for (const update of updates) {
        const { error: updateError } = await supabase
          .from('businesses')
          .update({ act_econ_code: update.act_econ_code })
          .eq('id', update.id);

        if (updateError) {
          console.error(`   ‚ùå Erreur update ${update.neq}:`, updateError.message);
        } else {
          updatedCount++;
        }
      }

      console.log(`   ‚úÖ Mis √† jour: ${updates.length} entreprises`);
      console.log(`   ‚è≠Ô∏è  Non trouv√© dans CSV: ${businesses.length - updates.length}`);
    }

    processedCount += businesses.length;

    // Progress
    const progress = ((processedCount / totalWithoutCode) * 100).toFixed(1);
    console.log(`   üìä Progr√®s: ${processedCount.toLocaleString()}/${totalWithoutCode.toLocaleString()} (${progress}%)`);

    // Small delay to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // 7. R√©sum√© final
  console.log('\n' + '='.repeat(80));
  console.log('‚úÖ SYNCHRONISATION TERMIN√âE');
  console.log('='.repeat(80));
  console.log(`
üìä STATISTIQUES:
   Lignes CSV lues:              ${records.length.toLocaleString()}
   Mappings NEQ‚ÜíACT_ECON:        ${neqToActEcon.size.toLocaleString()}

   Entreprises trait√©es:         ${processedCount.toLocaleString()}
   ‚úÖ Mises √† jour avec succ√®s:  ${updatedCount.toLocaleString()}
   ‚è≠Ô∏è  Non trouv√©es dans CSV:     ${notFoundCount.toLocaleString()}

   Batches trait√©s:              ${batchNumber}
  `);

  // 8. V√©rification finale
  console.log('6Ô∏è‚É£ V√©rification finale...\n');

  const { count: finalNull } = await supabase
    .from('businesses')
    .select('*', { count: 'exact', head: true })
    .is('act_econ_code', null);

  const { count: finalTotal } = await supabase
    .from('businesses')
    .select('*', { count: 'exact', head: true });

  const { count: finalWithCode } = await supabase
    .from('businesses')
    .select('*', { count: 'exact', head: true })
    .not('act_econ_code', 'is', null);

  console.log(`üìä √âTAT FINAL:`);
  console.log(`   Total entreprises:           ${finalTotal?.toLocaleString()}`);
  console.log(`   Avec act_econ_code:          ${finalWithCode?.toLocaleString()} (${((finalWithCode/finalTotal)*100).toFixed(2)}%)`);
  console.log(`   Sans act_econ_code (NULL):   ${finalNull?.toLocaleString()} (${((finalNull/finalTotal)*100).toFixed(2)}%)`);

  if (finalNull === 0) {
    console.log('\nüéâ COUVERTURE √Ä 100%! Toutes les entreprises ont un act_econ_code!');
  } else {
    console.log(`\n‚ö†Ô∏è  ${finalNull?.toLocaleString()} entreprises restent sans act_econ_code`);
    console.log('   Raisons possibles:');
    console.log('   - NEQ absent dans le CSV');
    console.log('   - NEQ NULL dans Supabase');
    console.log('   - ACT_ECON absent dans le CSV gouvernemental');
  }

  console.log('\n' + '='.repeat(80));
}

syncActEconFromCSV().catch(console.error);
