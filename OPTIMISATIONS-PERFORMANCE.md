# Optimisations de Performance - Registre du Qu√©bec

## Probl√®me Identifi√©
Les requ√™tes de recherche prennent 150-286ms, causant un d√©lai perceptible de ~1 seconde.

## Tests de Performance Effectu√©s

```
1Ô∏è‚É£ Filtre par cat√©gorie avec count exact: 265ms (20 r√©sultats)
2Ô∏è‚É£ Filtre par cat√©gorie SANS count: 286ms (20 r√©sultats)
   ‚ö° Gain: -21ms (-7.9%)

3Ô∏è‚É£ Table businesses directe: 150ms
   ‚ö° Gain vs view enriched: 136ms (47% plus rapide!)

4Ô∏è‚É£ Filtre par ville (ILIKE): 198ms
5Ô∏è‚É£ Recherche full-text: 265ms
```

## Optimisations Impl√©ment√©es

### 1. Optimisation du Code Frontend ‚úÖ

**Fichier:** `src/services/businessService.js`

- ‚úÖ Suppression de `count: 'exact'` sauf sur la premi√®re page
- ‚úÖ Suppression de count sur les requ√™tes al√©atoires

**Impact:** R√©duit la latence de ~20-50ms par requ√™te

### 2. Index de Base de Donn√©es üîß (√Ä cr√©er dans Supabase)

**Fichier:** `scripts/create-database-indexes.sql`

Ex√©cuter ces commandes dans l'√©diteur SQL de Supabase:

```sql
-- Index critiques pour performance
CREATE INDEX IF NOT EXISTS idx_businesses_main_category_id ON businesses(main_category_id);
CREATE INDEX IF NOT EXISTS idx_businesses_sub_category_id ON businesses(sub_category_id);
CREATE INDEX IF NOT EXISTS idx_businesses_city ON businesses(city);
CREATE INDEX IF NOT EXISTS idx_businesses_region ON businesses(region);
CREATE INDEX IF NOT EXISTS idx_businesses_mrc ON businesses(mrc);

-- Index composites pour filtres combin√©s
CREATE INDEX IF NOT EXISTS idx_businesses_category_city ON businesses(main_category_id, city);
CREATE INDEX IF NOT EXISTS idx_businesses_category_region ON businesses(main_category_id, region);

-- Index GIN pour full-text search (TR√àS IMPORTANT)
CREATE INDEX IF NOT EXISTS idx_businesses_search_vector ON businesses USING GIN(search_vector);

-- Index pour tri par date
CREATE INDEX IF NOT EXISTS idx_businesses_created_at ON businesses(created_at DESC);

-- Index pour NEQ et ACT_ECON
CREATE INDEX IF NOT EXISTS idx_businesses_neq ON businesses(neq);
CREATE INDEX IF NOT EXISTS idx_businesses_act_econ_code ON businesses(act_econ_code);
```

**Impact estim√©:** R√©duction de 50-70% de la latence (75-200ms ‚Üí 20-60ms)

## Optimisations Futures (Non Impl√©ment√©es)

### 3. Utiliser la Table Directe au Lieu de la View

**Avantage:** 47% plus rapide (150ms vs 286ms)

**Inconv√©nient:** Perd les jointures automatiques avec main_categories

**Recommandation:** Ajouter les champs d√©normalis√©s directement dans `businesses`:
- `main_category_slug`
- `main_category_name_fr`
- `main_category_name_en`

### 4. Cache Redis/CDN

Pour les requ√™tes les plus fr√©quentes:
- Page d'accueil (requ√™te al√©atoire)
- Top cat√©gories (Construction, Restauration, etc.)
- Cache TTL: 5-10 minutes

**Impact estim√©:** 90% de r√©duction (cache hit)

### 5. Pagination par Curseur

Au lieu de `offset/limit`, utiliser une pagination bas√©e sur ID:

```javascript
.gt('id', lastSeenId)
.limit(20)
```

**Avantage:** Performance constante m√™me sur les pages profondes

### 6. Lazy Loading des Cat√©gories

Charger les cat√©gories une seule fois au chargement de l'app et les mettre en cache local.

## R√©sum√© des Gains Attendus

| Optimisation | Gain | Statut |
|-------------|------|--------|
| Supprimer count inutiles | 20-50ms | ‚úÖ Fait |
| Index base de donn√©es | 100-200ms | üîß √Ä faire |
| Table directe vs view | 136ms | üìã Optionnel |
| Cache Redis | 200ms+ | üìã Futur |

## Actions Requises

1. **IMM√âDIAT** - Cr√©er les index SQL (copier/coller `scripts/create-database-indexes.sql`)
2. **APR√àS BUILD** - D√©ployer le code optimis√© (d√©j√† modifi√©)
3. **OPTIONNEL** - √âvaluer le besoin de cache Redis selon le trafic

## Monitoring

Apr√®s avoir cr√©√© les index, v√©rifier les performances avec:
```bash
node scripts/check-database-indexes.js
```

## Notes

- Les index GIN pour `search_vector` sont particuli√®rement critiques pour la recherche full-text
- Les index composites (category + city) acc√©l√®rent les filtres combin√©s
- La suppression de `count: 'exact'` am√©liore la performance sans impact UX (le count n'est affich√© que sur la premi√®re page)
